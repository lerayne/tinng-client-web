<link rel="import" href="../nodelist-base/nodelist-behavior.html">
<link rel="import" href="../card-post/card-post.html">

<dom-module id="nodelist-posts">

	<link rel="import" type="css" href="../nodelist-base/nodelist-base.css">

	<style>
		#scroll {
			padding: 15px 5px 1px 15px;
			position: relative;
		}

		#loadMore {
			margin-bottom:8px;
		}

		#loadMore text-string {
			text-align: center;
			display: block;
			padding:2px 0;
		}

		.loadMoreBtn {
			cursor:pointer;
		}

		.loadMoreBtn:hover {
			background-color: #ddd;
		}
	</style>

	<template>

		<div id="scroll">
			<div id="loadMore" hidden$="[[ showLoadMore(nodes, headLoaded) ]]">
				<text-string class="loadMoreBtn" on-tap="loadMore" hidden$="[[ loading ]]">unit.posts.loadMore</text-string>
				<text-string hidden$="[[ !loading ]]">unit.posts.loading</text-string>
			</div>

			<template is="dom-repeat" items="[[ nodes ]]" as="node">
				<card-post model="[[ node ]]"></card-post>
			</template>
		</div>

	</template>

	<script>
		Polymer({
			//polymer
			is:"nodelist-posts",

			behaviors:[
				tinng.polymerBehavior.Nodelist,
				tinng.polymerBehavior.Basic
			],

			//other
			sortOrder:'asc',
			headLoaded:false,

			showLoadMore:function(nodes, headLoaded){
				return nodes.length && !headLoaded
			},

			//other
			parseUpdates:function(nodes){

				var firstLoad = !this.nodes.length;
				var wasAtTop = this.isAtTop();

				// memorizing scroll position
				if (!firstLoad && wasAtTop) {
					var topPost = $(this.$.scroll).children('card-post').eq(0);
					var topOffset = topPost[0].offsetTop;
				}

				if (firstLoad) {
					// если это первичная загрузка

					this.headLoaded = false;

					//console.log('nodes', this.topic, _(nodes).find({id:this.topic}))

					if (typeof _(nodes).find({id:this.topic}) != 'undefined'){
						console.log('topic head loaded');
						this.headLoaded = true;
					}

					// если мы заполняем массив первый раз - нужно его отсортировать
					this.nodes = this.sort(nodes, this.sortField, this.sortOrder);

				} else {
					// если в массиве уже есть ноды
					_(nodes).each(this.processNode);
				}

				if (firstLoad || this.isAtBottom()) {
					this.async(this.toBottom)
				}

				// using memorized scroll position
				if (!firstLoad && wasAtTop) {
					this.async(function(){
						topPost[0].scrollIntoView();
						this.scrollTop = this.scrollTop - topOffset;
					})
				}

				this.loaded = true;
				this.loading = false;
			},

			processNode:function(data){
				//console.log(data.id, this.topic);

				//console.log('processNode')

				if (data.id == this.topic){
					console.log('topic head loaded')
					this.headLoaded = true;
				}

				this.NBProcessNode(data)

				//this.super(arguments);
			},

			showLoading:function(){
				this.loaded = false;
				this.loading = true;
			},

			loadMore:function(){
				this.fire('load-more');
				this.showLoading();
			}
		})
	</script>
</dom-module>