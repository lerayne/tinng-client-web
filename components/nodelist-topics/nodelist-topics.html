<link rel="import" href="../nodelist-base/nodelist-behavior.html">
<link rel="import" href="../card-topic/card-topic.html">
<link rel="import" href="../nodelist-base/nodelist-style.html">

<dom-module id="nodelist-topics">

	<style include="nodelist-style">
		#scroll {
			padding: 15px 5px 1px 15px;
		}
	</style>

	<template>

		<div id="scroll">
			<template is="dom-repeat" items="{{ nodes }}" as="node">
				<card-topic model="{{ node }}"></card-topic>
			</template>
		</div>

	</template>
</dom-module>

<script>
	Polymer({
		is: "nodelist-topics",

		behaviors:[
			tinng.polymerBehavior.Nodelist,
			tinng.polymerBehavior.Basic
		],

		sortField: 'updated',

		parseUpdates: function(nodes){

			_(nodes).each(this.prepareNode.bind(this));

			if (!this.nodes.length) {
				// если это первичная загрузка
				console.log('initial load', this.sort(nodes, this.sortField, this.sortOrder))

				// если мы заполняем массив первый раз - нужно его отсортировать
				this.nodes = this.sort(nodes, this.sortField, this.sortOrder);

			} else {
				// если в массиве уже есть ноды
				_(nodes).each(this.processNode);

				// todo - нужно либо отключить соблюдение сортировки в processItem, либо сделать условие на выполнение sortSelf
				// (было обновление) иначе - двойная работа. А еще лучше - сначала, если есть обновления, А ТАКЖЕ если от
				// обновлений может зависеть порядок - обновить и отсортировать, а затем добавить/удалить с само-сортировкой.
				// Чтобы понять, нужна ли сортировка - можно проверять, изменилось ли поле, по которому сортируем ;)
				this.sortSelf();
			}
		},

		markSelected:function(id){
			this.clearSelection();
			this.NLMarkSelected(id)
		}
	})
</script>