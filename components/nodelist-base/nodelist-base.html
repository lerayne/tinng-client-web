<polymer-element name="nodelist-base" attributes="updates">
	<template>
		<style>
			:host([loading]) {
				background: url(../../styles/throbber_1.gif) no-repeat center center;
			}
		</style>
	</template>

	<script>
		Polymer({

			//properties
			clientId:0,
			sortField:'created',
			sortOrder:'desc',

			//polymer
			publish:{
				loading: {value: false, reflect: true},
				loaded: {value: false, reflect: true}
			},

			observe:{
				sortField:'sortSelf',
				sortOrder:'sortSelf',
				updates:'parseUpdates',
				selectedIDs:'processSelected'
			},

			created:function(){
				this.nodes = [];
				this.selectedIDs = [];

				tinng.funcs.bind(this, [
					'processNode'
				]);
			},

			//other
			parseUpdates:function(old, nodes){
				console.log('updates', nodes)
			},

			clean:function(){
				this.nodes = [];
			},

			processNode:function(data){

				// находим индекс нужного элемента по id
				var existingItemIndex = _(this.nodes).findIndex({id: data.id});

				// если такого элемента нет - добавляем новый элемент в коллекцию
				if (existingItemIndex == -1) {

					// установка this.sortOrder в последний параметр актуальна только для сортировки по времени
					var sortIndex = tinng.funcs.getSortIndex(this.nodes, data, this.sortField, this.sortOrder, this.sortOrder)

					// вставляем новый элемент в нужное место
					if (sortIndex == this.nodes.length) {
						this.nodes.push(data)
					} else {
						this.nodes.splice(sortIndex, 0, data);
					}

				} else {
					if (+data.deleted) {
						// если есть и удален - удаляем из коллекции
						this.nodes.splice(existingItemIndex, 1)
					} else {
						// иначе - мягко обновляем существующий элемент (иначе пересоздается нода, обнуляя все свои свойства)
						// впрочем, теги и другие вложенные объекты сейчас пересоздаются, так что возможно (todo) создать функцию рекурсивного мягкого обновления
						for (var key in data) {
							this.nodes[existingItemIndex][key] = data[key];
						}
					}
				}
			},

			// сортировка по поданным параметрам (удобна для декларативного фильтра, который пока не работает)
			sort:function(input, sortField, sortOrder){

				var array = _(input).sortBy(sortField).value();
				if (sortOrder == 'desc') array.reverse();

				return array;
			},

			sortSelf:function(){
				this.nodes = this.sort(this.nodes, this.sortField, this.sortOrder)
			},

			isAtBottom:function(){
				return this.scrollHeight - (this.scrollTop + this.offsetHeight) == 0;
			},

			isAtTop:function(){
				return this.scrollTop == 0;
			},

			toBottom: function(){
				this.$.scroll.scrollIntoView(false)
			},

			toTop: function(){
				this.$.scroll.scrollIntoView(true)
			},

			prepareNode:function(node){
				// если у объекта нет id - присваеваем ему локальный клиентский id
				if (!node.id) node.id = 'client'+(this.clientId++);

				// making node selected on load
				// todo - make selected node to be scrolled to on load
				if (this.selectedIDs.indexOf(node.id) != -1) {
					console.log(node.id, 'is selected');
					node.selected = true;
				}
			},

			markSelected:function(id){
				this.selectedIDs.push(id);
			},

			clearSelection:function(){
				this.selectedIDs = [];

				_(this.nodes).each(function(node){
					if (node.selected) {
						node.selected = false;
					}
				})
			},

			processSelected:function(){
				var that = this;

				_(this.selectedIDs).each(function(id){
					var node = _(that.nodes).find(function(node){
						return node.id == id && !node.selected;
					});

					if (typeof node != 'undefined') {
						node.selected = true;
					}
				})
			}
		})
	</script>
</polymer-element>