<link rel="import" href="../../../bower_components/iron-collapse/iron-collapse.html">

<link rel="import" href="../unit/unit-behavior.html">
<link rel="import" href="../nodelist/nodelist-behavior.html">

<link rel="import" href="../unit/unit-style.html">
<link rel="import" href="../card-topic/card-topic.html">
<link rel="import" href="../block-slide-menu/block-slide-menu.html">
<link rel="import" href="../block-topics-search/block-topics-search.html">


<dom-module id="unit-topics">

	<style include="unit-style">
		:host {
			min-width: 350px;
			overflow: hidden;


		}

		@media (max-width: 350px) {
			:host {
				min-width: 200px;
			}
		}

		/* dont show close button in mobile view */
		:host-context(page-main-mobile) #close {
			display:none;
		}



		.text-container[opaque] {
			opacity: 1;
		}

		paper-toolbar .search {
			margin-right:0;
		}
	</style>

	<template>

		<iron-signals
			on-iron-signal-unit-topics="parseSignal"
			on-iron-signal-topic-loaded="onTopicLoaded"
			on-iron-signal-rescribe-all="subscribe"
		></iron-signals>

		<unit-topics-deco>

			<!-- MENU -->
			<!-- todo - find out why class (or any other attr) here can be binded only with $, while in login panel src is working -->
			<block-slide-menu id="slideMenu">
				<paper-item>Test menu item</paper-item>
			</block-slide-menu>

			<!-- TOOLBAR-->
			<paper-toolbar>

				<!-- MENU BUTTON -->
				<paper-icon-button icon="menu" on-click="menuShow"></paper-icon-button>

				<!-- UNIT HEADING -->
				<text-string hidden$="{{searchOn}}" id="unitHeader" class="flex">unit.topics.unitName</text-string>

				<!-- SEARCH -->
				<!--<block-topics-search></block-topics-search>-->

				<!-- only when used in units grid-->
				<span id="controlsEmbedded" class="horizontal layout center">
					<!--<paper-icon-button icon="chevron-left" id="hide"></paper-icon-button>-->
					<paper-icon-button id="close" icon="close" on-tap="suspend"></paper-icon-button>
				</span>
			</paper-toolbar>

			<!-- TOPICS LIST -->
			<div id="topicsList" class="nodes-container content vertical layout flex">
				<div id="scroll">
					<template is="dom-repeat" items="{{ nodes }}" as="node">
						<card-topic model="{{ node }}"></card-topic>
					</template>
				</div>
			</div>

			<paper-fab icon="note-add"></paper-fab>

		</unit-topics-deco>

	</template>


<script>
	Polymer({
		is:'unit-topics',

		behaviors:[
			tinng.polymerBehavior.Nodelist,
			tinng.polymerBehavior.Unit,
			tinng.polymerBehavior.Basic
		],

		ready:function(){
			this.subscribe();
		},


		// other
		subscribe: function() {

			this.clean();

			tinng.connection.subscribe({
				subscriber: this,
				feedName: 'topics-main',
				feed: {
					feed: 'topics'
				},
				parser: function(data) {
					this.parseUpdates(data);
				}
			});
		},

		clean:function(){
			this.nodes = [];
			tinng.connection.unscribe(this, 'topics-main');
		},


		// drafts

		onTopicLoaded:function(event, data, sender){

			if (this.markSelected) this.markSelected(data.id);
		},

		suspend: function () {
			/*
			* todo - Эта функция работает нестандартно: она посылает 2 сигнала, один - наверх (где он засекается элементом
			* разметки) и один широковещательно. Разметка закрывает колонку и посылает другой широковещ. сигнал, который
			* засекается текущим элементом. Некая часть этого сценария является полезной идеей, но в целом ее нужно
			* продумать лучше
			* */
			this.fire('suspend', {sender: this});
			this.fire('iron-signal', {name: 'secondary-close'});
		},

		parseSignal: function (event, data) {
			//console.log(data);
			if (data.command == 'suspend') {
				console.info('SUSPEND topics unit activity')
			}

			if (data.command == 'restore') {
				console.info('RESTORE topics unit activity')
			}
		},

		menuShow:function(){
			this.$.slideMenu.menuShow();
		},


		// From nodelist
		sortField: 'updated',

		parseUpdates: function(nodes){

			_(nodes).each(this.prepareNode.bind(this));

			if (!this.nodes.length) {
				// если это первичная загрузка
				//console.log('initial load', this.sort(nodes, this.sortField, this.sortOrder))

				// если мы заполняем массив первый раз - нужно его отсортировать
				this.nodes = this.sort(nodes, this.sortField, this.sortOrder);

			} else {
				// если в массиве уже есть ноды
				_(nodes).each(this.processNode);

				// todo - нужно либо отключить соблюдение сортировки в processItem, либо сделать условие на выполнение sortSelf
				// (было обновление) иначе - двойная работа. А еще лучше - сначала, если есть обновления, А ТАКЖЕ если от
				// обновлений может зависеть порядок - обновить и отсортировать, а затем добавить/удалить с само-сортировкой.
				// Чтобы понять, нужна ли сортировка - можно проверять, изменилось ли поле, по которому сортируем ;)
				this.sortSelf();
			}
		},

		markSelected:function(id){
			this.clearSelection();
			this.NLMarkSelected(id)
		}
	});
</script>