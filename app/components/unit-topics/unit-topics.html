<link rel="import" href="../../../bower_components/iron-collapse/iron-collapse.html">

<link rel="import" href="../unit/unit-behavior.html">
<link rel="import" href="../nodelist/nodelist-behavior.html">

<link rel="import" href="../unit/unit-style.html">

<link rel="import" href="../card-topic/card-topic.html">
<link rel="import" href="../block-slide-menu/block-slide-menu.html">
<link rel="import" href="../block-topics-search/block-topics-search.html">


<dom-module id="unit-topics">

	<style include="unit-style"></style>
	<style include="unit-topics-style"></style>
	<style>
		:host {
			min-width: 350px;
			overflow: hidden;
		}

		@media (max-width: 350px) {
			:host {
				min-width: 200px;
			}
		}

		/* dont show close button in mobile view */
		:host-context(page-main-mobile) #close {
			display:none;
		}

		.text-container[opaque] {
			opacity: 1;
		}

		paper-toolbar .search {
			margin-right:0;
		}
	</style>

	<template>

		<iron-signals
			on-iron-signal-unit-topics="parseSignal"
			on-iron-signal-topic-loaded="onTopicLoaded"
			on-iron-signal-rescribe-all="subscribe"
		></iron-signals>

		<unit-topics-deco>

			<!-- MENU -->
			<!-- todo - find out why class (or any other attr) here can be binded only with $, while in login panel src is working -->
			<block-slide-menu id="slideMenu">
				<paper-item>Test menu item</paper-item>
			</block-slide-menu>

			<!-- TOOLBAR-->
			<paper-toolbar>

				<!-- MENU BUTTON -->
				<paper-icon-button icon="menu" on-click="menuShow"></paper-icon-button>

				<!-- UNIT HEADING -->
				<text-string hidden$="{{searchOn}}" id="unitHeader" class="flex">unit.topics.unitName</text-string>

				<!-- SEARCH -->
				<!--<block-topics-search></block-topics-search>-->

				<!-- only when used in units grid-->
				<span id="controlsEmbedded" class="horizontal layout center">
					<!--<paper-icon-button icon="chevron-left" id="hide"></paper-icon-button>-->
					<paper-icon-button id="close" icon="close" on-tap="suspend" style="color: #039BE5"></paper-icon-button>
				</span>
			</paper-toolbar>

			<!-- TOPICS LIST -->
			<div id="nodelist" class="nodes-container content vertical layout flex">
				<div id="scroll">
					<template is="dom-repeat" items="{{ nodes }}" as="node">
						<card-topic model="{{ node }}"></card-topic>
					</template>
				</div>
			</div>

			<paper-fab icon="note-add"></paper-fab>

		</unit-topics-deco>

	</template>
</dom-module>

<script>
	Polymer({

		//
		//Polymer-specific fields
		//

		is:'unit-topics',

		behaviors:[
			tinng.polymerBehavior.Nodelist,
			tinng.polymerBehavior.Unit,
			tinng.polymerBehavior.Basic
		],

		ready:function(){
			// set default sorting
			this.sortField = 'updated';
			this.sortOrder = 'desc';

			this.subscribe();
		},



		/**
		 * Subscribes this unit to topic updates
		 */
		subscribe: function() {

			this.clean();

			tinng.connection.subscribe({
				subscriber: this,
				feedName: 'topics-main',
				feed: {
					feed: 'topics'
				},
				parser: function(data) {
					this.parseUpdates(data);
				}
			});
		},


		/**
		 * Transfer unit to initial state
		 */
		clean: function(){
			this.nodes = [];
			tinng.connection.unscribe(this, 'topics-main');
		},


		/**
		 * Main parsing function that transforms list of updates from server to the new model
		 */
		parseUpdates: function(nodes){

			// prepare all nodes
			_(nodes).each(this.prepareNode.bind(this));

			if (!this.nodes.length) {
				// если это первичная загрузка

				// если мы заполняем массив первый раз - просто присваеваем, отсортировав
				this.nodes = this.sort(nodes, this.sortField, this.sortOrder);

			} else {
				// если в массиве уже есть ноды - обработать каждую
				_(nodes).each(this.topics_processNode.bind(this));

				// todo - нужно либо отключить соблюдение сортировки в processNode, либо сделать условие на выполнение sortSelf
				// (было ли обновление) иначе - двойная работа. А еще лучше - сначала, если есть обновления, А ТАКЖЕ если от
				// обновлений может зависеть порядок - обновить и отсортировать, а затем добавить/удалить с само-сортировкой.
				// Чтобы понять, нужна ли сортировка - можно проверять, изменилось ли поле, по которому сортируем ;)
				this.sortSelf();
			}
		},


		/**
		 * Process separate node
		 */
		topics_processNode: function(data){
			this.processNode(data);
		},


		/**
		 * Show unit's slide-in menu
		 */
		menuShow: function(){
			this.$.slideMenu.menuShow();
		},


		// drafts

		onTopicLoaded:function(event, data, sender){

			this.topics_markSelected(data.id);
		},


		parseSignal: function (event, data) {
			//console.log(data);
			if (data.command == 'suspend') {
				console.info('SUSPEND topics unit activity')
			}

			if (data.command == 'restore') {
				console.info('RESTORE topics unit activity')
			}
		},


		topics_markSelected:function(id){
			this.clearSelection();
			this.markSelected(id)
		}
	});
</script>
